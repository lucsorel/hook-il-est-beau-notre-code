:toc:

= QualitÃ© de code - du commit Ã  la prod'

[%notitle]
== Quelque part dans un openspace de la startup nation...

image::assets/rideau_thÃ©Ã¢tre-jaune.jpg[background, size=cover]

[quote]
--
_Quelque part dans un openspace_

_de la startup nation..._
--

[.notes]
--
Proposition d'un petit sketch d'intro

Luc :

> Alors une nouvelle US... Hop hop, je code... Hop hop, je teste... vite fait...

> Hey JÃ©rÃ´me, veux-tu bien relire ma PR s'il te plaÃ®t ?

JÃ©rÃ´me :

> Oui oui...

> Mais, c'est n'imp' tes imports, lÃ  : tu importes un module du projet avant un module natif, ce n'est pas rÃ©glo... 

> et puis lÃ , c'est une bibliothÃ¨que tierce ! 

> Comment veux-tu qu'on s'y retrouve ?!?

JÃ©rÃ´me sors un mÃ¨tre Ã  mesurer et le pose sur l'Ã©cran

> Mais dis donc, ta ligne fait plus de 120 caractÃ¨res !
> Et puis qu'est-ce que c'est que ces strings avec des guillemets doubles Ã  cÃ´tÃ© des autres strings avec des guillemets simples. 
> C'est tout mÃ©langÃ©... 
> C'est la fÃªte du string, c'est Ã§a ?

> Rhooo ! Et ce dictionnaire au formatage tout dÃ©gueux... Dis, Ã§a n'est pas pour rien qu'on fait des rÃ©unions de conventions de code. Aller reformate-moi tout Ã§a et on en reparle.

JÃ©rÃ´me s'en va

Luc : 

> Mais, mais... Mais on n'a mÃªme pas parlÃ© du code mÃ©tier...
--

== QualitÃ© de code, conventions et relectures

Pourquoi nous relisons-nous ?

[%step]
* le code doit rendre le service mÃ©tier attendu
* perpÃ©tuer la robustesse et la maintenabilitÃ© du service numÃ©rique

[.notes]
--
Qui a dÃ©jÃ  vÃ©cu une scÃ¨ne similaire ?

Des scÃ¨nes de relecture de code comme Ã§a, il y en a plein.

L'objectif d'une relecture est de valider que le code rende le service mÃ©tier attendu tout en assurant une robustesse et une maintenabilitÃ© du service numÃ©rique.
--


== Vers une base de code robuste et maintenable 1/

[plantuml, target=mindmap-diagram, format=svg]
----
@startmindmap
+[#lightblue] base de code\nrobuste & maintenable
++[#yellow] conventions de code
+++ homogÃ©nÃ©itÃ©
++++ de style
+++++ formatage
+++++ docstring
++++ de (bonnes) pratiques
+++ intÃ©gration facile
++++ de nouvelles personnes
++++ de votre futur vous
@endmindmap
----

[.notes]
--
* de style : formatage, docstring
* bonnes pratiques : erreurs courantes comme des pb d'encodage non spÃ©cifiÃ©s, dÃ©tection d'anti-patterns, documentation manquante de modules ou de fonctions
* nouvelle personne : ou vous dans 3 mois
--

== Vers une base de code robuste et maintenable 2/

[plantuml, target=mindmap-diagram, format=svg]
----
@startmindmap
+[#lightblue] base de code\nrobuste & maintenable
--[#lightyellow] conventions de code
--- homogÃ©nÃ©itÃ©
---- de style
----- formatage
----- docstring
---- de (bonnes) pratiques
--- intÃ©gration facile
---- de nouvelles personnes
---- de votre futur vous
++[#yellow] tests automatisÃ©s
+++ confiance dans la base de code
+++ documente l'utilisation du code
@endmindmap
----

[.notes]
--
* documentation : entrÃ©es et sorties de fonctions, cas d'erreur gÃ©rÃ©s
--

== Vers une base de code robuste et maintenable 3/

[plantuml, target=mindmap-diagram, format=svg]
----
@startmindmap
+[#lightblue] base de code\nrobuste & maintenable
--[#lightyellow] conventions de code
--- homogÃ©nÃ©itÃ©
---- de style
----- formatage
----- docstring
---- de (bonnes) pratiques
--- intÃ©gration facile
---- de nouvelles personnes
---- de votre futur vous
++[#yellow] intÃ©gration continue
+++ validations humaines
++++ relecture de tÃ¢ches
++++ story keeping de user stories
+++[#lightgreen] vÃ©rifications automatisÃ©es
++[#lightyellow] tests automatisÃ©s
+++ confiance dans la base de code
+++ documente l'utilisation du code
@endmindmap
----

== VÃ©rifications automatisÃ©es

Que connaissez-vous comme vÃ©rifications automatisÃ©es de la qualitÃ© de code ?


[%step]
* tests automatisÃ©s
** en contrÃ´lant la couverture de code : `pytest-cov`
** en contrÃ´lant la conso mÃ©moire : `memray`
* analyse statique de code
** respect de formatage : `isort`, `black`, `yapf`
** dÃ©tection d'antipatterns : `pylint`, `flake8`, `ruff`, `perflint`

[.notes]
--
L'analyse statique est souvent faite par un outil comme sonar, qui se dÃ©roule souvent une fois que le commit est parti.
--

== Et si l'analyse statique commenÃ§ait au commit ?

_(juste avant, en fait...)_

[.notes]
--
C'est un peu dommage, on ne va pas faire une palanquÃ©e de commits pour arriver Ã  un code satisfaisant (c'est un peu le dÃ©faut d'une mise en place d'intÃ©gration continue).
--

== Les hooks git

Conditionne une action git "classique" Ã  la bonne exÃ©cution d'un script.

[source,text]
----
super-projet
  â”œâ”€ .git
  â”‚Â  â””â”€ hooks/
  â”‚Â     â”œâ”€ commit-msg.sample
  â”‚Â     â”œâ”€ pre-commit.sample ğŸ‘€
  â”‚Â     â”œâ”€ pre-push.sample
  â”‚Â     â”œâ”€ pre-receive.sample
  â”‚Â     â””â”€ ...
----


* retirer `.sample` pour activer le hook
* le contexte d'exÃ©cution est la racine du projet git, pas `.git/hooks`

[.notes]
--
Un hook de prÃ©-commit semble Ãªtre le bon moment avant que l'Ã©ventuelle honte quitte l'intimitÃ© de notre poste de travail et se rÃ©pande dans l'intÃ©gration continue et la production.
--

== Example de hook de pre-commit


[source, bash]
----
# ğŸ“„ .git/hooks/pre-commit
#!/bin/sh
echo "Pre-commit hook launched in $(pwd)"

# simulates an error code at exit
exit 1
----

[source, bash]
----
mkdir super-projet
cd super-projet
git init -b main
git config ...

git touch test
git add test
git status
git commit -m "ğŸ‰"
git status
----

== Comment mutualiser les hooks ?

[%step]
* crÃ©er un dossier contenant les hooks (`.git_hooks`, par exemple)
** ğŸ‘ faire un lien symbolique entre `.git_hooks` et .git/hooks
** ğŸ‘ OU configurer git pour y chercher les hooks : `git config core.hooksPath ./.git_hooks`
* ğŸ‘ğŸ‘ utiliser un outil qui va gÃ©rer la _tambouille-as-code_ entre les hooks git et les outils de vÃ©rification : `pre-commit`
